//位域的概念：有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用0和1表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种数据结构，叫做“位域”或“位段”。

//位域是操控位的一种方法，操控位的另一种方法是使用按位运算符。

//位域通过一个结构声明来建立：该结构声明为每个字段提供标签，并确定该字段的宽度。例如，下面的声明建立了个4个1位的字段：

struct
{
	unsigned int autfd: 1; //:后面的数字用来限定成员变量占用的位数。
	unsigned int bldfc: 1;
	unsigned int undin: 1;
	unsigned int itals: 1;
} prnt;

//根据该声明，prnt包含4个1位的字段。现在，可以通过普通的结构成员运算符(.)单独给这些字段赋值：

prnt.itals = 0:
             prnt.undin = 1;

//由于每个字段恰好为1位，所以只能为其赋值1或0。

//位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度，:后面的数字不能超过这个长度。

//如上述结构中autfd、bldfc、undin、itals后面的数字不能超过unsigned int的位数，即在32bit环境中就是不能超过32。

//位域的取值范围非常有限，数据稍微大些就会发生溢出，请看下面的例子：

#include <stdio.h>

struct pack
{
	unsigned a: 2; // 取值范围为：0~3
	unsigned b: 4;  // 取值范围为：0~15
	unsigned c: 6;  // 取值范围为：0~63
};

int main(void)
{
	struct pack pk1;
	struct pack pk2;

// 给pk1各成员赋值并打印输出
	pk1.a = 1;
	pk1.b = 10;
	pk1.c = 50;
	printf("%d, %d, %d\n", pk1.a, pk1.b, pk1.c);

// 给pk2各成员赋值并打印输出
	pk2.a = 5;
	pk2.b = 20;
	pk2.c = 66;
	printf("%d, %d, %d\n", pk2.a, pk2.b, pk2.c);

	return 0;
}

//程序输出结果为：

pk1.a = 1, pk1.a = 10, pk1.c = 5
pk2.a = 1, pk2.b = 4, pk2.c = 2

//结构体变量pk1的各成员都没有超出限定的位数，能够正常输出。而结构体变量pk2的各成员超出了限定的位数，并发生了上溢